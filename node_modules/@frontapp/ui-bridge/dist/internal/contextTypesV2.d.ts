import { ApplicationCancelToken } from './asyncTypesV2';
import { ApplicationChannelList } from './channelTypesV2';
import { ApplicationConversation, ApplicationConversationStatus, ApplicationSingleConversation } from './conversationTypesV2';
import { ApplicationDraft, ApplicationDraftTemplate, ApplicationDraftUpdate } from './draftTypesV2';
import { EntryPointTypesEnum } from './entryPointTypesV2';
import { HttpRequest, HttpResponse } from './httpTypesV2';
import { ApplicationDraftId, ApplicationInboxId, ApplicationTagId, ApplicationTeammateId } from './idTypesV2';
import { ApplicationInboxList } from './inboxTypesV2';
import { ApplicationMessageList } from './messageTypesV2';
import { ApplicationPaginationToken } from './paginationTypesV2';
import { ApplicationTagList } from './tagTypesV2';
import { ApplicationTeammate, ApplicationTeammateList } from './teammateTypesV2';
import { ApplicationTopic } from './topicTypesV2';
import { Widget, WidgetTemplate } from './widgetTypesV2';
export interface ApplicationContextBase {
    /** Unique ID for this context. */
    id: string;
    /** Unique ID of the Entry Point this context was created from. */
    entryPointId: string;
    /** Unique ID of the component that hosts this entry point. */
    hostId: string;
    /** List of function names supported by this context object with their arity. */
    functionArities: {
        [K: string]: number;
    };
    /** Current teammate's preferences for this application. */
    preferences: object;
    /** Current teammate. */
    teammate: ApplicationTeammate;
    /**
     * Create a new Widget for the current context.
     * @param template Definition of the Widget to create.
     * @param cancelToken Cancel the creation of the Widget.
     * @returns Newly created Widget.
     */
    createWidget(template: WidgetTemplate, cancelToken?: ApplicationCancelToken): Promise<Widget>;
    /**
     * Destroy an existing Widget.
     * @param widgetId ID of the Widget to destroy.
     * @param cancelToken Cancel the Widget destruction.
     */
    destroyWidget(widgetId: string, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Send an HTTP request to the private API of the application.
     * @param request Definition of the HTTP request to run.
     * @param cancelToken Cancel the HTTP request.
     * @returns HTTP response.
     */
    sendHttp(request: HttpRequest, cancelToken?: ApplicationCancelToken): Promise<HttpResponse>;
    /**
     * Open a browser window.
     * @param url URL to navigate to.
     */
    openUrl(url: string, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Open a browser popup.
     * @param url URL to open.
     * @param options Optional object to define the properties of the popup.
     */
    openUrlInPopup(url: string, options: {
        width?: number;
        height?: number;
    } | undefined, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Perform a search in Front for the current teammate.
     * @param query Search query.
     * @param cancelToken Cancel the search request.
     */
    search(query: string, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * List the teammates of the company.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of teammates.
     */
    listTeammates(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationTeammateList>;
    /**
     * List the inboxes accessible by the current teammate.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of inboxes.
     */
    listInboxes(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationInboxList>;
    /**
     * List the channels accessible by the current teammate.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of channels.
     */
    listChannels(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationChannelList>;
    /**
     * List the tags accessible by the current teammate.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of tags.
     */
    listTags(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationTagList>;
    /**
     * Create a draft.
     * @param template Properties of the draft to create
     * @param cancelToken Cancel the request.
     * @returns The newly created draft.
     */
    createDraft(template: ApplicationDraftTemplate, cancelToken?: ApplicationCancelToken): Promise<ApplicationDraft>;
    /**
     * Update a draft.
     * @param draftId ID of the draft to update.
     * @param update Properties of the draft to update.
     * @param cancelToken Cancel the request.
     */
    updateDraft(draftId: ApplicationDraftId, update: ApplicationDraftUpdate, cancelToken?: ApplicationCancelToken): Promise<void>;
}
export interface NoConversationContext extends ApplicationContextBase {
    type: 'noConversation';
}
export interface ExistingConversationBaseContext extends ApplicationContextBase {
    /**
     * Add a topic to the selected conversations.
     * @param externalUrl URL of the topic.
     * @param name Human readable name.
     * @param cancelToken Cancel the creation of the link.
     * @returns The added topic.
     */
    addTopic(externalUrl: string, name: string | undefined, cancelToken?: ApplicationCancelToken): Promise<ApplicationTopic>;
    /**
     * Assign or unassign the selected conversations.
     * @param teammateId ID of the teammate to assign the conversations to. If null, the conversations will be unassigned.
     * @param cancelToken Cancel the request.
     */
    assign(teammateId: ApplicationTeammateId | null, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Move the selected conversations to an inbox.
     * @param inboxId ID of the inbox.
     * @param cancelToken Cancel the request.
     */
    move(inboxId: ApplicationInboxId, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Set the status of the selected conversations.
     * @param status Conversation status to apply.
     * @param cancelToken Cancel the request.
     */
    setStatus(status: ApplicationConversationStatus, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Add the specified tags to the selected conversations.
     * @param tagIds Tag IDs to add.
     * @param cancelToken Cancel the request.
     */
    tag(tagIds: ReadonlyArray<ApplicationTagId>, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Remove the specified tags from the selected conversations.
     * @param tagIds Tag IDs to remove.
     * @param cancelToken Cancel the request.
     */
    untag(tagIds: ReadonlyArray<ApplicationTagId>, cancelToken?: ApplicationCancelToken): Promise<void>;
}
export interface SingleConversationContext extends ExistingConversationBaseContext {
    type: 'singleConversation';
    /** The selected conversation. */
    conversation: ApplicationSingleConversation;
    /**
     * Fetch a draft by ID.
     * @param draftId ID of the draft to fetch.
     * @param cancelToken Cancel the request.
     * @returns The draft, if found.
     */
    fetchDraft(draftId: ApplicationDraftId, cancelToken?: ApplicationCancelToken): Promise<ApplicationDraft | undefined>;
    /**
     * List the messages in the current conversation.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of messages.
     */
    listMessages(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationMessageList>;
}
export interface MultiConversationsContext extends ExistingConversationBaseContext {
    type: 'multiConversations';
    /** Selected conversations */
    conversations: ReadonlyArray<ApplicationConversation>;
}
export declare type ExistingConversationContext = SingleConversationContext | MultiConversationsContext;
export declare type ConversationContext = NoConversationContext | SingleConversationContext | MultiConversationsContext;
export interface MessageContext extends ApplicationContextBase {
    type: 'message';
    messageId: string;
}
export declare type ApplicationContext = ConversationContext | MessageContext;
interface ContextMap {
    [EntryPointTypesEnum.CONVERSATION_LINK_DROPDOWN]: ExistingConversationContext;
    [EntryPointTypesEnum.MESSAGE_MORE_DROPDOWN]: MessageContext;
    [EntryPointTypesEnum.SIDE_PANEL]: ConversationContext;
}
export declare type ContextOf<T extends keyof ContextMap> = ContextMap[T];
export {};
