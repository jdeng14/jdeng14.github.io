"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ApiClient = _interopRequireDefault(require("../ApiClient"));

var _DocumentAssignmentParameters = _interopRequireDefault(require("../model/DocumentAssignmentParameters"));

var _DocumentAssignmentResponse = _interopRequireDefault(require("../model/DocumentAssignmentResponse"));

var _DocumentDeleteResponse = _interopRequireDefault(require("../model/DocumentDeleteResponse"));

var _DocumentParameters = _interopRequireDefault(require("../model/DocumentParameters"));

var _DocumentPretranslateParameters = _interopRequireDefault(require("../model/DocumentPretranslateParameters"));

var _DocumentPretranslateResponse = _interopRequireDefault(require("../model/DocumentPretranslateResponse"));

var _DocumentUpdateParameters = _interopRequireDefault(require("../model/DocumentUpdateParameters"));

var _DocumentWithSegments = _interopRequireDefault(require("../model/DocumentWithSegments"));

var _Error = _interopRequireDefault(require("../model/Error"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
* Documents service.
* @module api/DocumentsApi
* @version 0.5.0
*/
var DocumentsApi = /*#__PURE__*/function () {
  /**
  * Constructs a new DocumentsApi. 
  * @alias module:api/DocumentsApi
  * @class
  * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
  * default to {@link module:ApiClient#instance} if unspecified.
  */
  function DocumentsApi(apiClient) {
    _classCallCheck(this, DocumentsApi);

    this.apiClient = apiClient || _ApiClient["default"].instance;
  }
  /**
   * Assign a Document
   * Assign and unassign a Document for translation and/or review.  
   * @param {module:model/DocumentAssignmentParameters} body 
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentAssignmentResponse} and HTTP response
   */


  _createClass(DocumentsApi, [{
    key: "assignDocumentWithHttpInfo",
    value: function assignDocumentWithHttpInfo(body) {
      var postBody = body; // verify the required parameter 'body' is set

      if (body === undefined || body === null) {
        throw new _Error["default"]("Missing the required parameter 'body' when calling assignDocument");
      }

      var pathParams = {};
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _DocumentAssignmentResponse["default"];
      return this.apiClient.callApi('/documents/share', 'PUT', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Assign a Document
     * Assign and unassign a Document for translation and/or review.  
     * @param {module:model/DocumentAssignmentParameters} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentAssignmentResponse}
     */

  }, {
    key: "assignDocument",
    value: function assignDocument(body) {
      return this.assignDocumentWithHttpInfo(body).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Create a Document
     * Create a new Document. A Document is a collection of one or more Segments. Documents are nested inside of Projects, and appear in the Project details view in the web app. Document-level relationships between Segments are considered by the machine translation system during adaptation. If there is no inherent document structure in your data, you still might consider grouping related Segments into Documents to improve translation quality. 
     * @param {Object} opts Optional parameters
     * @param {module:model/DocumentParameters} opts.body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentWithSegments} and HTTP response
     */

  }, {
    key: "createDocumentWithHttpInfo",
    value: function createDocumentWithHttpInfo(opts) {
      opts = opts || {};
      var postBody = opts['body'];
      var pathParams = {};
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _DocumentWithSegments["default"];
      return this.apiClient.callApi('/documents', 'POST', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Create a Document
     * Create a new Document. A Document is a collection of one or more Segments. Documents are nested inside of Projects, and appear in the Project details view in the web app. Document-level relationships between Segments are considered by the machine translation system during adaptation. If there is no inherent document structure in your data, you still might consider grouping related Segments into Documents to improve translation quality. 
     * @param {Object} opts Optional parameters
     * @param {module:model/DocumentParameters} opts.body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentWithSegments}
     */

  }, {
    key: "createDocument",
    value: function createDocument(opts) {
      return this.createDocumentWithHttpInfo(opts).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Delete a Document
     * Delete a Document. 
     * @param {Number} id A unique Document identifier.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentDeleteResponse} and HTTP response
     */

  }, {
    key: "deleteDocumentWithHttpInfo",
    value: function deleteDocumentWithHttpInfo(id) {
      var postBody = null; // verify the required parameter 'id' is set

      if (id === undefined || id === null) {
        throw new _Error["default"]("Missing the required parameter 'id' when calling deleteDocument");
      }

      var pathParams = {};
      var queryParams = {
        'id': id
      };
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = _DocumentDeleteResponse["default"];
      return this.apiClient.callApi('/documents', 'DELETE', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Delete a Document
     * Delete a Document. 
     * @param {Number} id A unique Document identifier.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentDeleteResponse}
     */

  }, {
    key: "deleteDocument",
    value: function deleteDocument(id) {
      return this.deleteDocumentWithHttpInfo(id).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Download a Document
     * Export a Document that has been translated in the Lilt web application. Any Document can be downloaded in XLIFF 1.2 format, or can be retrieved in its original uploaded format by setting `is_xliff=false`. This endpoint will fail if either (a) export or (b) pre-translation operations are in-progress. The status of those operations can be determined by retrieving the Document resource. Example CURL command: ```   curl -X GET https://lilt.com/2/documents/files?key=API_KEY&id=274 -o from_lilt.xliff ```  
     * @param {Number} id An unique Document identifier.
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.isXliff Download the document in XLIFF 1.2 format. (default to true)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Blob} and HTTP response
     */

  }, {
    key: "downloadDocumentWithHttpInfo",
    value: function downloadDocumentWithHttpInfo(id, opts) {
      opts = opts || {};
      var postBody = null; // verify the required parameter 'id' is set

      if (id === undefined || id === null) {
        throw new _Error["default"]("Missing the required parameter 'id' when calling downloadDocument");
      }

      var pathParams = {};
      var queryParams = {
        'id': id,
        'is_xliff': opts['isXliff']
      };
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = [];
      var accepts = ['application/octet-stream'];
      var returnType = 'Blob';
      return this.apiClient.callApi('/documents/files', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Download a Document
     * Export a Document that has been translated in the Lilt web application. Any Document can be downloaded in XLIFF 1.2 format, or can be retrieved in its original uploaded format by setting `is_xliff=false`. This endpoint will fail if either (a) export or (b) pre-translation operations are in-progress. The status of those operations can be determined by retrieving the Document resource. Example CURL command: ```   curl -X GET https://lilt.com/2/documents/files?key=API_KEY&id=274 -o from_lilt.xliff ```  
     * @param {Number} id An unique Document identifier.
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.isXliff Download the document in XLIFF 1.2 format. (default to true)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Blob}
     */

  }, {
    key: "downloadDocument",
    value: function downloadDocument(id, opts) {
      return this.downloadDocumentWithHttpInfo(id, opts).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Retrieve a Document
     * List a Document.  The listing will include the pretranslation status for the document. When pretranslation is in progress for a document, the `GET /documents` endpoint's response will include `is_pretranslating = true` as well as a more detailed status property `status.pretranslation` one of `idle`, `pending`, or `running`.
     * @param {Number} id A unique Document identifier.
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.withSegments Flag indicating whether full segment information should be returned.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentWithSegments} and HTTP response
     */

  }, {
    key: "getDocumentWithHttpInfo",
    value: function getDocumentWithHttpInfo(id, opts) {
      opts = opts || {};
      var postBody = null; // verify the required parameter 'id' is set

      if (id === undefined || id === null) {
        throw new _Error["default"]("Missing the required parameter 'id' when calling getDocument");
      }

      var pathParams = {};
      var queryParams = {
        'id': id,
        'with_segments': opts['withSegments']
      };
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = _DocumentWithSegments["default"];
      return this.apiClient.callApi('/documents', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Retrieve a Document
     * List a Document.  The listing will include the pretranslation status for the document. When pretranslation is in progress for a document, the `GET /documents` endpoint's response will include `is_pretranslating = true` as well as a more detailed status property `status.pretranslation` one of `idle`, `pending`, or `running`.
     * @param {Number} id A unique Document identifier.
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.withSegments Flag indicating whether full segment information should be returned.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentWithSegments}
     */

  }, {
    key: "getDocument",
    value: function getDocument(id, opts) {
      return this.getDocumentWithHttpInfo(id, opts).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Pretranslate a Document
     * Initiate pretranslation of a list of Documents. This request will mark document(s) as being pretranslated. Pretranslation in this context is: - Applying and confirming exact TM matches based on the Memory of the Project; - Translating all other segments via MT without confirming them.  Example cURL command: ``` curl -X POST https://lilt.com/2/documents/pretranslate?key=API_KEY -d {\"id\": [123]} -H \"Content-Type: application/json\" ```  Document translation is an asynchronous process that, in effect, is performed in the background.  To check the status of pretranslation for a document, use the `GET /documents` endpoint. When pretranslation is in progress for a document, the `GET /documents` endpoint's response will include `is_pretranslating = true` as well as a more detailed status property `status.pretranslation` one of `idle`, `pending`, or `running`.  Once pretranslation is finished, the document can be downloaded via `GET /documents/files`. 
     * @param {module:model/DocumentPretranslateParameters} body 
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.autoAccept Optional parameter for auto-accepting 100% TM hits.
     * @param {Boolean} opts.caseSensitive Optional for using case matching against TM hits.
     * @param {Boolean} opts.attributeToCreator Optional parameter for attributing translation authorship of exact matches to document creator.
     * @param {String} opts.mode An optional parameter indicating how the document will be pretranslated.  The accepted values are `tm`, or `tm+mt`. Default is `tm+mt`. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentPretranslateResponse} and HTTP response
     */

  }, {
    key: "pretranslateDocumentsWithHttpInfo",
    value: function pretranslateDocumentsWithHttpInfo(body, opts) {
      opts = opts || {};
      var postBody = body; // verify the required parameter 'body' is set

      if (body === undefined || body === null) {
        throw new _Error["default"]("Missing the required parameter 'body' when calling pretranslateDocuments");
      }

      var pathParams = {};
      var queryParams = {
        'auto_accept': opts['autoAccept'],
        'case_sensitive': opts['caseSensitive'],
        'attribute_to_creator': opts['attributeToCreator'],
        'mode': opts['mode']
      };
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _DocumentPretranslateResponse["default"];
      return this.apiClient.callApi('/documents/pretranslate', 'POST', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Pretranslate a Document
     * Initiate pretranslation of a list of Documents. This request will mark document(s) as being pretranslated. Pretranslation in this context is: - Applying and confirming exact TM matches based on the Memory of the Project; - Translating all other segments via MT without confirming them.  Example cURL command: ``` curl -X POST https://lilt.com/2/documents/pretranslate?key=API_KEY -d {\"id\": [123]} -H \"Content-Type: application/json\" ```  Document translation is an asynchronous process that, in effect, is performed in the background.  To check the status of pretranslation for a document, use the `GET /documents` endpoint. When pretranslation is in progress for a document, the `GET /documents` endpoint's response will include `is_pretranslating = true` as well as a more detailed status property `status.pretranslation` one of `idle`, `pending`, or `running`.  Once pretranslation is finished, the document can be downloaded via `GET /documents/files`. 
     * @param {module:model/DocumentPretranslateParameters} body 
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.autoAccept Optional parameter for auto-accepting 100% TM hits.
     * @param {Boolean} opts.caseSensitive Optional for using case matching against TM hits.
     * @param {Boolean} opts.attributeToCreator Optional parameter for attributing translation authorship of exact matches to document creator.
     * @param {String} opts.mode An optional parameter indicating how the document will be pretranslated.  The accepted values are `tm`, or `tm+mt`. Default is `tm+mt`. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentPretranslateResponse}
     */

  }, {
    key: "pretranslateDocuments",
    value: function pretranslateDocuments(body, opts) {
      return this.pretranslateDocumentsWithHttpInfo(body, opts).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Update a Document
     * Update a Document. 
     * @param {module:model/DocumentUpdateParameters} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentWithSegments} and HTTP response
     */

  }, {
    key: "updateDocumentWithHttpInfo",
    value: function updateDocumentWithHttpInfo(body) {
      var postBody = body; // verify the required parameter 'body' is set

      if (body === undefined || body === null) {
        throw new _Error["default"]("Missing the required parameter 'body' when calling updateDocument");
      }

      var pathParams = {};
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _DocumentWithSegments["default"];
      return this.apiClient.callApi('/documents', 'PUT', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Update a Document
     * Update a Document. 
     * @param {module:model/DocumentUpdateParameters} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentWithSegments}
     */

  }, {
    key: "updateDocument",
    value: function updateDocument(body) {
      return this.updateDocumentWithHttpInfo(body).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
    /**
     * Upload a File
     * Create a Document from a file in any of the formats [documented in our knowledge base](https://support.lilt.com/hc/en-us/articles/360020816253-File-Formats). Request parameters should be passed as JSON object with the header  field `LILT-API`. Example CURL command: ```   curl -X POST https://lilt.com/2/documents/files?key=API_KEY \\   --header \"LILT-API: {\\\"name\\\": \\\"introduction.xliff\\\",\\\"pretranslate\\\": \\\"tm+mt\\\",\\\"project_id\\\": 9}\" \\   --header \"Content-Type: application/octet-stream\" \\   --data-binary @Introduction.xliff ```  
     * @param {String} name A file name.
     * @param {Number} projectId A unique Project identifier.
     * @param {String} body The file contents to be uploaded. The entire POST body will be treated as the file. 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretranslate An optional parameter indicating if and how the document will be pretranslated upon being uploaded.  The accepted values are `null`, `tm`, or `tm+mt` 
     * @param {Boolean} opts.autoAccept An optional parameter to auto-accept segments with 100% translation memory matches when the `pretranslate` option is also set, or to auto-accept any target data that is present when the uploaded file is XLIFF. If omitted or set to `false`, no segments will be auto-accepted. 
     * @param {Number} opts.configId An optional pararameter to specify an import configuration to be applied when extracting translatable content from this file. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentWithSegments} and HTTP response
     */

  }, {
    key: "uploadDocumentWithHttpInfo",
    value: function uploadDocumentWithHttpInfo(name, projectId, body, opts) {
      opts = opts || {};
      var postBody = body; // verify the required parameter 'name' is set

      if (name === undefined || name === null) {
        throw new _Error["default"]("Missing the required parameter 'name' when calling uploadDocument");
      } // verify the required parameter 'projectId' is set


      if (projectId === undefined || projectId === null) {
        throw new _Error["default"]("Missing the required parameter 'projectId' when calling uploadDocument");
      } // verify the required parameter 'body' is set


      if (body === undefined || body === null) {
        throw new _Error["default"]("Missing the required parameter 'body' when calling uploadDocument");
      }

      var pathParams = {};
      var queryParams = {};
      var headerParams = {
        'name': name,
        'project_id': projectId,
        'pretranslate': opts['pretranslate'],
        'auto_accept': opts['autoAccept'],
        'config_id': opts['configId']
      };
      var formParams = {};
      var authNames = ['ApiKeyAuth', 'BasicAuth'];
      var contentTypes = ['application/octet-stream'];
      var accepts = ['application/json'];
      var returnType = _DocumentWithSegments["default"];
      return this.apiClient.callApi('/documents/files', 'POST', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Upload a File
     * Create a Document from a file in any of the formats [documented in our knowledge base](https://support.lilt.com/hc/en-us/articles/360020816253-File-Formats). Request parameters should be passed as JSON object with the header  field `LILT-API`. Example CURL command: ```   curl -X POST https://lilt.com/2/documents/files?key=API_KEY \\   --header \"LILT-API: {\\\"name\\\": \\\"introduction.xliff\\\",\\\"pretranslate\\\": \\\"tm+mt\\\",\\\"project_id\\\": 9}\" \\   --header \"Content-Type: application/octet-stream\" \\   --data-binary @Introduction.xliff ```  
     * @param {String} name A file name.
     * @param {Number} projectId A unique Project identifier.
     * @param {String} body The file contents to be uploaded. The entire POST body will be treated as the file. 
     * @param {Object} opts Optional parameters
     * @param {String} opts.pretranslate An optional parameter indicating if and how the document will be pretranslated upon being uploaded.  The accepted values are `null`, `tm`, or `tm+mt` 
     * @param {Boolean} opts.autoAccept An optional parameter to auto-accept segments with 100% translation memory matches when the `pretranslate` option is also set, or to auto-accept any target data that is present when the uploaded file is XLIFF. If omitted or set to `false`, no segments will be auto-accepted. 
     * @param {Number} opts.configId An optional pararameter to specify an import configuration to be applied when extracting translatable content from this file. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentWithSegments}
     */

  }, {
    key: "uploadDocument",
    value: function uploadDocument(name, projectId, body, opts) {
      return this.uploadDocumentWithHttpInfo(name, projectId, body, opts).then(function (response_and_data) {
        return response_and_data.data;
      });
    }
  }]);

  return DocumentsApi;
}();

exports["default"] = DocumentsApi;